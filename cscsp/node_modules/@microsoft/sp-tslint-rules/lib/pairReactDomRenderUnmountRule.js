"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule = void 0;
const tsUtils = __importStar(require("tsutils"));
const ts = __importStar(require("typescript"));
const Lint = __importStar(require("tslint"));
// tslint:disable:export-name
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithFunction(sourceFile, this.walk.bind(this));
    }
    walk(ctx) {
        const renderCalls = [];
        const unmountCalls = [];
        // Do not convert `callback` to a function. It references `this` keyword inside it.
        const callback = (node) => {
            const reactDOMImportNamespaceName = this.getReactDOMImportNamespaceName(node);
            if (reactDOMImportNamespaceName) {
                this.reactDOMImportNamespaceName = reactDOMImportNamespaceName;
                return;
            }
            const isRenderCallExpression = this.isReactDOMCallExpression(node, 'render');
            if (isRenderCallExpression) {
                renderCalls.push(node);
                return;
            }
            const isUnmountCallExpression = this.isReactDOMCallExpression(node, 'unmountComponentAtNode');
            if (isUnmountCallExpression) {
                unmountCalls.push(node);
                return;
            }
            ts.forEachChild(node, callback);
        };
        ts.forEachChild(ctx.sourceFile, callback);
        // Verify the count of render calls and unmount calls are the same in the file.
        if (renderCalls.length !== unmountCalls.length) {
            renderCalls.concat(unmountCalls).forEach((renderCallExpression) => {
                ctx.addFailureAtNode(renderCallExpression, 'Unmatched calls between `ReactDOM.render` and `ReactDOM.unmountComponentAtNode`.');
            });
        }
    }
    getReactDOMImportNamespaceName(node) {
        if (
        // import * as ReactDOM from 'react-dom'
        tsUtils.isImportDeclaration(node) &&
            // * as ReactDOM
            node.importClause &&
            tsUtils.isImportClause(node.importClause) &&
            // ReactDOM
            node.importClause.namedBindings &&
            tsUtils.isNamespaceImport(node.importClause.namedBindings) &&
            // 'react-dom'
            tsUtils.isStringLiteral(node.moduleSpecifier) &&
            node.moduleSpecifier.text === 'react-dom') {
            return node.importClause.namedBindings.name.text;
        }
        else {
            return undefined;
        }
    }
    isReactDOMCallExpression(node, methodName) {
        return (
        // ReactDOM.method(param1, param2)
        tsUtils.isCallExpression(node) &&
            // ReactDOM.method
            tsUtils.isPropertyAccessExpression(node.expression) &&
            // ReactDOM
            tsUtils.isIdentifier(node.expression.expression) &&
            node.expression.expression.text === this.reactDOMImportNamespaceName &&
            // method
            tsUtils.isIdentifier(node.expression.name) &&
            node.expression.name.text === methodName);
    }
}
exports.Rule = Rule;
Rule.metadata = {
    ruleName: 'pair-react-dom-render-unmount',
    description: 'Pair ReactDOM render and unmount calls in one file.' +
        ' If a ReactDOM render tree is not unmounted when disposed, it will cause a memory leak.',
    rationale: 'Pair the render and unmount calls to avoid memory leak.',
    optionsDescription: 'No options available.',
    options: {},
    type: 'maintainability',
    typescriptOnly: false
};
//# sourceMappingURL=pairReactDomRenderUnmountRule.js.map